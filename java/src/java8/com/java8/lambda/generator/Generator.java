package com.java8.lambda.generator;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

import com.google.common.base.Charsets;
import com.google.common.base.Joiner;
import com.google.common.reflect.TypeToken;

/**
 * 
 * 
 * @author EMAIL:vuquangtin@gmail.com , tel:0377443333
 * @version 1.0.0
 * @see <a href="https://github.com/vuquangtin/frameworks">https://github.com/
 *      vuquangtin/frameworks</a>
 *
 */
public class Generator {
	private static final String UNCHECKERS_SITE_URL = "http://github.com/JohnGlassmyer/uncheckers";

	public static String generate(List<Class<?>> samTypes, Class<? extends Exception> checkedExceptionClass,
			Class<? extends Throwable> uncheckedExceptionClass, String uncheckersPackageName,
			String uncheckersEnclosingClassName, String checkedInterfaceNamePrefix, String checkedInterfaceNameSuffix,
			String uncheckerMethodNamePrefix, String uncheckerMethodNameSuffix) {
		if (isCheckedException(uncheckedExceptionClass)) {
			throw new IllegalArgumentException(
					String.format("%s is a checked exception type", uncheckedExceptionClass.getName()));
		}

		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		PrintStream printStream = new PrintStream(baos);

		printStream.println("// generated by " + UNCHECKERS_SITE_URL);
		printStream.println();
		printStream.format("package %s;\n", uncheckersPackageName);
		printStream.println();
		printStream.println("// checked exception type");
		printStream.format("import %s;\n", checkedExceptionClass.getName());
		printStream.println();
		printStream.println("// unchecked exception type");
		printStream.format("import %s;\n", uncheckedExceptionClass.getName());

		printStream.println();

		printStream.println("// classes to uncheck");
		for (Class<?> clazz : samTypes) {
			printStream.format("import %s;\n", clazz.getName());
		}

		printStream.println();

		String uncheckersEnclosingClassJavadoc = String.format(
				"/**" + "\n * Static helper methods which wrap and re-throw" + "\n * {@link %s %s}"
						+ "\n * in {@link %s %s}" + "\n * so that methods known to throw {@code %s}"
						+ "\n * can be more easily called in functional contexts,"
						+ "\n * for example with {@link java.util.stream.Stream Streams}." + "\n *"
						+ "\n * @see <a href=\"%s\"" + "\n * >%s</a>" + "\n */",
				checkedExceptionClass.getName(), checkedExceptionClass.getSimpleName(),
				uncheckedExceptionClass.getName(), uncheckedExceptionClass.getSimpleName(),
				checkedExceptionClass.getSimpleName(), UNCHECKERS_SITE_URL, UNCHECKERS_SITE_URL);

		printStream.println(uncheckersEnclosingClassJavadoc);
		printStream.format("public class %s {\n", uncheckersEnclosingClassName);

		Set<Class<?>> processedSamTypes = new HashSet<>();
		Set<String> processedSamTypeSimpleNames = new HashSet<>();
		for (Class<?> samType : samTypes) {
			if (!processedSamTypes.isEmpty()) {
				printStream.println();
			}

			String samTypeSimpleName = samType.getSimpleName();

			if (processedSamTypeSimpleNames.contains(samTypeSimpleName)) {
				throw new IllegalArgumentException(String
						.format("the list of SAM types includes more than one with simpleName %s", samTypeSimpleName));
			}

			processedSamTypeSimpleNames.add(samTypeSimpleName);

			if (processedSamTypes.contains(samType)) {
				throw new IllegalArgumentException(
						String.format("the list of SAM types includes %s more than once", samType.getName()));
			}

			processedSamTypes.add(samType);

			String samTypeTypeParams = samType.getTypeParameters().length > 0
					? "<" + Joiner.on(", ").join(samType.getTypeParameters()) + ">" : "";

			String samTypeNameWithTypeParams = samTypeSimpleName + samTypeTypeParams;

			String uncheckerMethodName = uncheckerMethodNamePrefix + samTypeSimpleName + uncheckerMethodNameSuffix;
			String checkedInterfaceName = checkedInterfaceNamePrefix + samTypeSimpleName + checkedInterfaceNameSuffix;
			String checkedInterfaceNameWithTypeParams = checkedInterfaceName + samTypeTypeParams;
			String checkedInterfaceInstanceName = Character.toLowerCase(checkedInterfaceName.charAt(0))
					+ checkedInterfaceName.substring(1);

			TypeToken<?> typeToken = TypeToken.of(samType);

			List<Method> methods = Arrays.asList(samType.getMethods()).stream()
					.filter(m -> Modifier.isAbstract(m.getModifiers())).filter(m -> !isMethodOfObject(m))
					.collect(Collectors.toList());
			if (methods.size() != 1) {
				throw new RuntimeException(String.format("%s has %d abstract methods: %s", samType.getName(),
						methods.size(), methods.stream().map(m -> m.getName()).collect(Collectors.toList())));
			}

			Method method = methods.get(0);

			for (Type genericExceptionType : method.getGenericExceptionTypes()) {
				Class<?> rawExceptionType = typeToken.resolveType(genericExceptionType).getRawType();
				if (isCheckedException(rawExceptionType)) {
					throw new IllegalArgumentException(String.format("SAM method %s.%s throws checked exception %s",
							samType.getName(), method.getName(), rawExceptionType.getName()));
				}
			}

			TypeToken<?> methodReturnType = typeToken.resolveType(method.getGenericReturnType());
			List<TypeToken<?>> methodParameterTypes = Arrays.asList(method.getGenericParameterTypes()).stream()
					.map(typeToken::resolveType).collect(Collectors.toList());

			List<String> methodParams = new ArrayList<>();
			List<String> methodArgs = new ArrayList<>();

			Map<TypeToken<?>, Long> methodParamTypeCounts = methodParameterTypes.stream()
					.collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));

			Map<String, Integer> countByName = new HashMap<>();
			methodParameterTypes.stream().forEachOrdered(t -> {
				String typeName = t.getType().getTypeName();
				String paramName = paramNameForTypeName(typeName);
				String dedupedParamName;
				if (methodParamTypeCounts.get(t) == 1) {
					dedupedParamName = paramName;
				} else {
					int count = countByName.compute(paramName, (n, c) -> (c == null) ? 0 : (c + 1));
					dedupedParamName = paramName + count;
				}
				methodParams.add(typeName + " " + dedupedParamName);
				methodArgs.add(dedupedParamName);
			});

			String joinedMethodParams = methodParams.stream().collect(Collectors.joining(", "));
			String joinedMethodArgs = methodArgs.stream().collect(Collectors.joining(", "));

			String checkedInterfaceJavadoc = String.format(
					"\t/**" + "\n\t * A lambda or functional interface" + "\n\t * known to throw {@code %s}"
							+ "\n\t * but otherwise convertible to {@code %s}." + "\n\t */",
					checkedExceptionClass.getSimpleName(), samTypeSimpleName);

			printStream.format(
					"%s" + "\n\t@FunctionalInterface" + "\n\tpublic interface %s {"
							+ "\n\t\tpublic %s %s(%s) throws %s;" + "\n\t}",
					checkedInterfaceJavadoc, checkedInterfaceNameWithTypeParams, methodReturnType, method.getName(),
					joinedMethodParams, checkedExceptionClass.getSimpleName());
			printStream.println();
			printStream.println();

			String uncheckerMethodJavadoc = String.format(
					"\t/**" + "\n\t * Calls the given {@link %s %s}-like"
							+ "\n\t * lambda or functional interface instance,"
							+ "\n\t * wrapping and re-throwing any thrown {@code %s}" + "\n\t * in a new {@code %s}."
							+ "\n\t */",
					samType.getName(), samTypeSimpleName, checkedExceptionClass.getSimpleName(),
					uncheckedExceptionClass.getSimpleName());

			printStream.format(
					"%s" + "\n\tpublic static %s%s %s(%s %s) {" + "\n\t\treturn (%s) -> {" + "\n\t\t\ttry {"
							+ "\n\t\t\t\t%s%s.%s(%s);" + "\n\t\t\t} catch (%s e) {" + "\n\t\t\t\tthrow new %s(e);"
							+ "\n\t\t\t}" + "\n\t\t};" + "\n\t}",
					uncheckerMethodJavadoc, samTypeTypeParams + (samTypeTypeParams.isEmpty() ? "" : " "),
					samTypeNameWithTypeParams, uncheckerMethodName, checkedInterfaceNameWithTypeParams,
					checkedInterfaceInstanceName, joinedMethodArgs,
					method.getReturnType().equals(Void.TYPE) ? "" : "return ", checkedInterfaceInstanceName,
					method.getName(), joinedMethodArgs, checkedExceptionClass.getSimpleName(),
					uncheckedExceptionClass.getSimpleName());
			printStream.println();
		}

		printStream.println("}");

		try {
			return baos.toString(Charsets.UTF_8.name());
		} catch (UnsupportedEncodingException e) {
			// you got me this time..
			throw new RuntimeException(e);
		}
	}

	private static boolean isMethodOfObject(Method m) {
		for (Method objectMethod : Object.class.getDeclaredMethods()) {
			if (m.getName().equals(objectMethod.getName())
					&& Arrays.equals(m.getParameterTypes(), objectMethod.getParameterTypes())) {
				return true;
			}
		}

		return false;
	}

	private static boolean isCheckedException(Class<?> clazz) {
		return Exception.class.isAssignableFrom(clazz) && !RuntimeException.class.isAssignableFrom(clazz);
	}

	private static String paramNameForTypeName(String typeName) {
		return typeName.equals(typeName.toUpperCase()) ? typeName.toLowerCase() : typeName.substring(0, 1);
	}
}